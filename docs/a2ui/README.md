# A2A User Interface (A2UI) Integration

This document details the integration of the **Agent-to-Agent User Interface (A2UI)** protocol within the `k8s-autopilot` framework. This integration allows the agent to render rich, interactive UI components (Cards, Buttons, Lists) in compatible clients, replacing standard text-only responses.

---

## 1. Overview

The A2UI integration transforms the agent from a text-based chatbot into a rich interactive application. Instead of streaming raw tokens, the agent sends structured JSON payloads conforming to the A2UI specification.

**Key Benefits:**
*   **Rich Visualization**: Status cards, icons, and structured layouts.
*   **Interactive Gates**: "Approve" / "Reject" buttons for Human-in-the-Loop (HITL) workflows.
*   **Structured Inputs**: Values confirmation forms instead of open-ended text prompts.
*   **Programmatic Reliability**: UI is generated by deterministic Python builders, not hallucinated by the LLM.

---

## 2. Architecture Components

The integration consists of three main layers:

### 2.1 Extension Definition (`a2ui_extension.py`)
**Role**: Protocol Contract
*   Defines the extension URI: `https://a2ui.org/a2a-extension/a2ui/v0.8`
*   Defines the MIME type: `application/json+a2ui`
*   Provides helper functions (`create_a2ui_part`, `is_a2ui_part`) to wrap/unwrap UI payloads in A2A `DataParts`.

### 2.2 UI Builder (`a2ui_builder.py`)
**Role**: View Layer (Templates)
A library of programmatic builders that generate valid A2UI JSON structures. This ensures validity and consistency.

**Supported Surfaces**:
*   **Status Card**: (`build_working_status_a2ui`) Shows current agent status with a spinner/icon.
*   **Completion Card**: (`build_completion_a2ui`) Green success state with summary.
*   **Error Card**: (`build_error_a2ui`) Red error state with details.
*   **Info Card**: (`build_info_message_a2ui`) General information without actions.
*   **HITL Approval Form**: (`build_hitl_approval_a2ui`) Interactive form with "Approve"/"Reject" buttons.
*   **Values Confirmation**: (`build_values_confirmation_a2ui`) Specialized form for accepting default values.

### 2.3 Executor Integration (`a2a_autopilot_executor.py`)
**Role**: Controller / Router
The `A2AAutoPilotExecutor` orchestrates the UI generation process:
1.  **Detection**: Checks `try_activate_a2ui_extension(context)` to see if the client supports UI.
2.  **Routing**: Intercepts agent stream items (`is_task_complete`, `require_user_input`).
3.  **Generation**: Calls `_create_a2ui_parts` which delegates to the appropriate builder in `a2ui_builder.py`.
4.  **Action Handling**: Processes incoming `userAction` payloads (button clicks) and converts them into agent-comprehensible queries.

---

## 3. Data Flow

### 3.1 Initial Request (Client -> Agent)
When a client connects, it must Request the A2UI extension in the handshake.
If active, `A2AAutoPilotExecutor` sets `use_ui=True`.

### 3.2 Response Generation (Agent -> Client)
As the agent streams responses:
1.  The Agent yields an `AgentResponse` (text or data).
2.  The Executor catches this response.
3.  **If `use_ui` is True**:
    *   The Executor analyzes the metadata (Status, Phase, HITL requirements).
    *   It selects a template (e.g., `build_hitl_approval_a2ui`).
    *   It wraps the result in a `DataPart` with MIME type `application/json+a2ui`.
4.  **If `use_ui` is False**:
    *   It sends standard `TextPart` or `DataPart`.

### 3.3 User Interaction (Client -> Agent)
When a user clicks a button (e.g., "Approve"):
1.  The Client sends a message containing a `DataPart` with a `userAction` field.
2.  The Executor detects this `userAction` in `context.message.parts`.
3.  It converts the structured action into a text query:
    *   *Input*: `userAction: {name: "hitl_response", context: {decision: "approved"}}`
    *   *Converted*: `"USER_ACTION: hitl_response, CONTEXT: {"decision": "approved"}"`
4.  The standard Agent logic processes this "query" as if the user typed it.

---

## 4. Key Implementation Details

### Interactive HITL Gates
The system intelligently detects when to show interactive buttons versus informational text.

**Logic in `build_a2ui_for_response`**:
*   **Explicit Gates**: Checks if `metadata['interrupt_type']` matches `hitl_gate`, `planning_review`, etc.
*   **Content Types**: Checks if `content['type']` is `tool_call_approval_request`.
*   **Fallback**: If purely conversational, renders an Info card without buttons.

**Button Actions**:
Buttons are configured to send `hitl_response` actions with context:
```json
"action": {
    "name": "hitl_response",
    "context": [
        {"key": "decision", "value": {"literalString": "approved"}},
        {"key": "phase", "value": {"path": "phaseId"}}
    ]
}
```

### Programmatic vs Generative UI
Unlike some agent frameworks that ask the LLM to "generate JSON UI" (which is error-prone), k8s-autopilot uses **Programmatic Builders**.
*   **LLM Role**: Generates the *content* (summary text, reasoning).
*   **Python Role**: Wraps that content in a robust, validated UI structure.

---

## 5. Reference

*   **Source Code**:
    *   [`a2ui_extension.py`](../../a2ui_extenstion/src/a2ui/a2ui_extension.py)
    *   [`a2ui_builder.py`](../../k8s_autopilot/core/a2ui/a2ui_builder.py)
    *   [`a2a_autopilot_executor.py`](../../k8s_autopilot/core/a2a_autopilot_executor.py)
*   **Standard**: [A2UI Specification](https://a2ui.org)
